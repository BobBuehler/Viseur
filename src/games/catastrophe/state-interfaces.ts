// These are the interfaces for all the states in this game
import { IBaseGameObjectState, IBaseGameState, IBasePlayerState } from "src/viseur/game";

// This is a file generated by the Creer, it may have empty interfaces,
// but we need them, so let's disable that tslint rule
// tslint:disable:no-empty-interface

/**
 * Convert as many humans to as you can to survive in this post-apocalyptic
 * wasteland.
 */
export interface IGameState extends IBaseGameState {
    /**
     * The multiplier for the amount of energy regenerated when resting in a
     * base with the cat overlord.
     */
    catEnergyMult: number;

    /**
     * The player whose turn it is currently. That player can send commands.
     * Other players cannot.
     */
    currentPlayer: IPlayerState;

    /**
     * The current turn number, starting at 0 for the first player's turn.
     */
    currentTurn: number;

    /**
     * A mapping of every game object's ID to the actual game object. Primarily
     * used by the server and client to easily refer to the game objects via ID.
     */
    gameObjects: {[id: string]: IGameObjectState};

    /**
     * All the Jobs that Units can have in the game.
     */
    jobs: IJobState[];

    /**
     * The number of Tiles in the map along the y (vertical) axis.
     */
    mapHeight: number;

    /**
     * The number of Tiles in the map along the x (horizontal) axis.
     */
    mapWidth: number;

    /**
     * The maximum number of turns before the game will automatically end.
     */
    maxTurns: number;

    /**
     * List of all the players in the game.
     */
    players: IPlayerState[];

    /**
     * A unique identifier for the game instance that is being played.
     */
    session: string;

    /**
     * The multiplier for the amount of energy regenerated when resting while
     * starving.
     */
    starvingEnergyMult: number;

    /**
     * Every Structure in the game.
     */
    structures: IStructureState[];

    /**
     * All the tiles in the map, stored in Row-major order. Use `x + y *
     * mapWidth` to access the correct index.
     */
    tiles: ITileState[];

    /**
     * Every Unit in the game.
     */
    units: IUnitState[];

}

/**
 * An object in the game. The most basic class that all game classes should
 * inherit from automatically.
 */
export interface IGameObjectState extends IBaseGameObjectState {
    /**
     * String representing the top level Class that this game object is an
     * instance of. Used for reflection to create new instances on clients, but
     * exposed for convenience should AIs want this data.
     */
    gameObjectName: string;

    /**
     * A unique id for each instance of a GameObject or a sub class. Used for
     * client and server communication. Should never change value after being
     * set.
     */
    id: string;

    /**
     * Any strings logged will be stored here. Intended for debugging.
     */
    logs: string[];

}

/**
 * Information about a Unit's job.
 */
export interface IJobState extends IGameObjectState {
    /**
     * The amount of energy this Job normally uses to perform its actions.
     */
    actCost: number;

    /**
     * How many combined resources a Unit with this Job can hold at once.
     */
    carryLimit: number;

    /**
     * The number of moves this Job can make per turn.
     */
    moves: number;

    /**
     * The amount of energy normally regenerated when resting at a shelter.
     */
    regenRate: number;

    /**
     * The Job title.
     */
    title: string;

    /**
     * The amount of food per turn this Unit consumes. If there isn't enough
     * food for every Unit, all units become starved and do not consume food.
     */
    upkeep: number;

}

/**
 * A player in this game. Every AI controls one player.
 */
export interface IPlayerState extends IGameObjectState, IBasePlayerState {
    /**
     * The overlord cat Unit owned by this Player.
     */
    cat: IUnitState;

    /**
     * What type of client this is, e.g. 'Python', 'JavaScript', or some other
     * language. For potential data mining purposes.
     */
    clientType: string;

    /**
     * The amount of food owned by this player.
     */
    food: number;

    /**
     * If the player lost the game or not.
     */
    lost: boolean;

    /**
     * The name of the player.
     */
    name: string;

    /**
     * This player's opponent in the game.
     */
    opponent: IPlayerState;

    /**
     * The reason why the player lost the game.
     */
    reasonLost: string;

    /**
     * The reason why the player won the game.
     */
    reasonWon: string;

    /**
     * Every Structure owned by this Player.
     */
    structures: IStructureState[];

    /**
     * The amount of time (in ns) remaining for this AI to send commands.
     */
    timeRemaining: number;

    /**
     * Every Unit owned by this Player.
     */
    units: IUnitState[];

    /**
     * The total upkeep of every Unit owned by this Player.
     */
    upkeep: number;

    /**
     * If the player won the game or not.
     */
    won: boolean;

}

/**
 * A structure on a Tile.
 */
export interface IStructureState extends IGameObjectState {
    /**
     * The range of this Structure's effect. For example, a radius of 1 means
     * this Structure affects a 3x3 square centered on this Structure.
     */
    effectRadius: number;

    /**
     * The number of materials in this Structure.
     */
    materials: number;

    /**
     * The owner of this Structure if any, otherwise null.
     */
    owner: IPlayerState;

    /**
     * The Tile this structure is on.
     */
    tile: ITileState;

    /**
     * The type of structure this is.
     */
    type: string;

}

/**
 * A Tile in the game that makes up the 2D map grid.
 */
export interface ITileState extends IGameObjectState {
    /**
     * The number of food dropped on this Tile.
     */
    food: number;

    /**
     * The amount of food that can be harvested from this tile per turn.
     */
    harvestRate: number;

    /**
     * The number of materials dropped on this Tile.
     */
    materials: number;

    /**
     * The structure on this Tile if present, otherwise null.
     */
    structure: string;

    /**
     * The Tile to the 'East' of this one (x+1, y). Null if out of bounds of the
     * map.
     */
    tileEast: ITileState;

    /**
     * The Tile to the 'North' of this one (x, y-1). Null if out of bounds of
     * the map.
     */
    tileNorth: ITileState;

    /**
     * The Tile to the 'South' of this one (x, y+1). Null if out of bounds of
     * the map.
     */
    tileSouth: ITileState;

    /**
     * The Tile to the 'West' of this one (x-1, y). Null if out of bounds of the
     * map.
     */
    tileWest: ITileState;

    /**
     * What type of Tile this is.
     */
    type: string;

    /**
     * The Unit on this Tile if present, otherwise null.
     */
    unit: IUnitState;

    /**
     * The x (horizontal) position of this Tile.
     */
    x: number;

    /**
     * The y (vertical) position of this Tile.
     */
    y: number;

}

/**
 * A unit in the game.
 */
export interface IUnitState extends IGameObjectState {
    /**
     * Whether this unit has performed its action this turn.
     */
    acted: boolean;

    /**
     * The amount of energy this unit has (from 0.0 to 1.0).
     */
    energy: number;

    /**
     * The amount of food this Unit is holding.
     */
    food: number;

    /**
     * The Job this Unit was recruited to do.
     */
    job: IJobState;

    /**
     * The amount of materials this Unit is holding.
     */
    materials: number;

    /**
     * The tile this Unit is moving to. This only applies to neutral fresh
     * humans spawned on the road.
     */
    movementTarget: ITileState;

    /**
     * How many moves this Unit has left this turn.
     */
    moves: number;

    /**
     * The Player that owns and can control this Unit, or null if the unit is
     * neutral.
     */
    owner: IPlayerState;

    /**
     * The units in the same squad as this unit. Units in the same squad attack
     * and defend together.
     */
    squad: IUnitState[];

    /**
     * Whether this unit is starving. Starving units regenerate energy at half
     * the rate they normally would while resting.
     */
    starving: boolean;

    /**
     * The Tile this Unit is on.
     */
    tile: ITileState;

    /**
     * The number of turns before this Unit dies. This only applies to neutral
     * fresh humans created from combat.
     */
    turnsToDie: number;

}
