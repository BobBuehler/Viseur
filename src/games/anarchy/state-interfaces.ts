// These are the interfaces for all the states in this game
import { IBaseGameObjectState, IBaseGameState, IBasePlayerState } from "src/viseur/game";

// This is a file generated by the Creer, it may have empty interfaces,
// but we need them, so let's disable that tslint rule
// tslint:disable:no-empty-interface

/**
 * Two player grid based game where each player tries to burn down the other
 * player's buildings. Let it burn.
 */
export interface IGameState extends IBaseGameState {
    /**
     * How many bribes players get at the beginning of their turn, not counting
     * their burned down Buildings.
     */
    readonly baseBribesPerTurn: number;

    /**
     * All the buildings in the game.
     */
    readonly buildings: IBuildingState[];

    /**
     * The current Forecast, which will be applied at the end of the turn.
     */
    readonly currentForecast: IForecastState;

    /**
     * The player whose turn it is currently. That player can send commands.
     * Other players cannot.
     */
    readonly currentPlayer: IPlayerState;

    /**
     * The current turn number, starting at 0 for the first player's turn.
     */
    readonly currentTurn: number;

    /**
     * All the forecasts in the game, indexed by turn number.
     */
    readonly forecasts: IForecastState[];

    /**
     * A mapping of every game object's ID to the actual game object. Primarily
     * used by the server and client to easily refer to the game objects via ID.
     */
    readonly gameObjects: {[id: string]: IGameObjectState};

    /**
     * The width of the entire map along the vertical (y) axis.
     */
    readonly mapHeight: number;

    /**
     * The width of the entire map along the horizontal (x) axis.
     */
    readonly mapWidth: number;

    /**
     * The maximum amount of fire value for any Building.
     */
    readonly maxFire: number;

    /**
     * The maximum amount of intensity value for any Forecast.
     */
    readonly maxForecastIntensity: number;

    /**
     * The maximum number of turns before the game will automatically end.
     */
    readonly maxTurns: number;

    /**
     * The next Forecast, which will be applied at the end of your opponent's
     * turn. This is also the Forecast WeatherStations can control this turn.
     */
    readonly nextForecast: IForecastState;

    /**
     * List of all the players in the game.
     */
    readonly players: IPlayerState[];

    /**
     * A unique identifier for the game instance that is being played.
     */
    readonly session: string;

}

/**
 * A basic building. It does nothing besides burn down. Other Buildings inherit
 * from this class.
 */
export interface IBuildingState extends IGameObjectState {
    /**
     * When true this building has already been bribed this turn and cannot be
     * bribed again this turn.
     */
    readonly bribed: boolean;

    /**
     * The Building directly to the east of this building, or null if not
     * present.
     */
    readonly buildingEast: IBuildingState;

    /**
     * The Building directly to the north of this building, or null if not
     * present.
     */
    readonly buildingNorth: IBuildingState;

    /**
     * The Building directly to the south of this building, or null if not
     * present.
     */
    readonly buildingSouth: IBuildingState;

    /**
     * The Building directly to the west of this building, or null if not
     * present.
     */
    readonly buildingWest: IBuildingState;

    /**
     * How much fire is currently burning the building, and thus how much damage
     * it will take at the end of its owner's turn. 0 means no fire.
     */
    readonly fire: number;

    /**
     * How much health this building currently has. When this reaches 0 the
     * Building has been burned down.
     */
    readonly health: number;

    /**
     * True if this is the Headquarters of the owning player, false otherwise.
     * Burning this down wins the game for the other Player.
     */
    readonly isHeadquarters: boolean;

    /**
     * The player that owns this building. If it burns down (health reaches 0)
     * that player gets an additional bribe(s).
     */
    readonly owner: IPlayerState;

    /**
     * The location of the Building along the x-axis.
     */
    readonly x: number;

    /**
     * The location of the Building along the y-axis.
     */
    readonly y: number;

}

/**
 * Can put out fires completely.
 */
export interface IFireDepartmentState extends IBuildingState {
    /**
     * The amount of fire removed from a building when bribed to extinguish a
     * building.
     */
    readonly fireExtinguished: number;

}

/**
 * The weather effect that will be applied at the end of a turn, which causes
 * fires to spread.
 */
export interface IForecastState extends IGameObjectState {
    /**
     * The Player that can use WeatherStations to control this Forecast when its
     * the nextForecast.
     */
    readonly controllingPlayer: IPlayerState;

    /**
     * The direction the wind will blow fires in. Can be 'north', 'east',
     * 'south', or 'west'.
     */
    readonly direction: string;

    /**
     * How much of a Building's fire that can be blown in the direction of this
     * Forecast. Fire is duplicated (copied), not moved (transfered).
     */
    readonly intensity: number;

}

/**
 * An object in the game. The most basic class that all game classes should
 * inherit from automatically.
 */
export interface IGameObjectState extends IBaseGameObjectState {
    /**
     * String representing the top level Class that this game object is an
     * instance of. Used for reflection to create new instances on clients, but
     * exposed for convenience should AIs want this data.
     */
    readonly gameObjectName: string;

    /**
     * A unique id for each instance of a GameObject or a sub class. Used for
     * client and server communication. Should never change value after being
     * set.
     */
    readonly id: string;

    /**
     * Any strings logged will be stored here. Intended for debugging.
     */
    readonly logs: string[];

}

/**
 * A player in this game. Every AI controls one player.
 */
export interface IPlayerState extends IGameObjectState, IBasePlayerState {
    /**
     * How many bribes this player has remaining to use during their turn. Each
     * action a Building does costs 1 bribe. Any unused bribes are lost at the
     * end of the player's turn.
     */
    readonly bribesRemaining: number;

    /**
     * All the buildings owned by this player.
     */
    readonly buildings: IBuildingState[];

    /**
     * What type of client this is, e.g. 'Python', 'JavaScript', or some other
     * language. For potential data mining purposes.
     */
    readonly clientType: string;

    /**
     * All the FireDepartments owned by this player.
     */
    readonly fireDepartments: IFireDepartmentState[];

    /**
     * The Warehouse that serves as this player's headquarters and has extra
     * health. If this gets destroyed they lose.
     */
    readonly headquarters: IWarehouseState;

    /**
     * If the player lost the game or not.
     */
    readonly lost: boolean;

    /**
     * The name of the player.
     */
    readonly name: string;

    /**
     * This player's opponent in the game.
     */
    readonly opponent: IPlayerState;

    /**
     * All the PoliceDepartments owned by this player.
     */
    readonly policeDepartments: IPoliceDepartmentState[];

    /**
     * The reason why the player lost the game.
     */
    readonly reasonLost: string;

    /**
     * The reason why the player won the game.
     */
    readonly reasonWon: string;

    /**
     * The amount of time (in ns) remaining for this AI to send commands.
     */
    readonly timeRemaining: number;

    /**
     * All the warehouses owned by this player. Includes the Headquarters.
     */
    readonly warehouses: IWarehouseState[];

    /**
     * All the WeatherStations owned by this player.
     */
    readonly weatherStations: IWeatherStationState[];

    /**
     * If the player won the game or not.
     */
    readonly won: boolean;

}

/**
 * Used to keep cities under control and raid Warehouses.
 */
export interface IPoliceDepartmentState extends IBuildingState {
}

/**
 * A typical abandoned warehouse... that anarchists hang out in and can be
 * bribed to burn down Buildings.
 */
export interface IWarehouseState extends IBuildingState {
    /**
     * How exposed the anarchists in this warehouse are to PoliceDepartments.
     * Raises when bribed to ignite buildings, and drops each turn if not
     * bribed.
     */
    readonly exposure: number;

    /**
     * The amount of fire added to buildings when bribed to ignite a building.
     * Headquarters add more fire than normal Warehouses.
     */
    readonly fireAdded: number;

}

/**
 * Can be bribed to change the next Forecast in some way.
 */
export interface IWeatherStationState extends IBuildingState {
}
